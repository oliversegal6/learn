
## Mongodb

### 高可用（多副本Replication)

Mongo 副本集是多个mongod实例，一般为3个，一个primary二个Secondary.Primary 把所有的数据修改存入**operation log(oplog)**, Secondaries**异步复制** Primary的oplog把数据修改入自己的数据集。如果Primary不可用，Secondary会开始一个选举，选出一个新的Primary.

![Alt text](./pic/mongo1.svg)

- One primary.
- Two secondary members. Both secondaries can become the primary in an election.

![Alt text](./pic/mongo3.svg)

还有另外一种创建副本集的方式，如果Primary和Secondary的个数是偶数个，可以加一个Arbiter做为仲裁节点，它不保存数据。Quorom 机制，是一种分布式系统中常用的，用来保证数据冗余和最终一致性的投票算法。加入Arbiter的目的是为了维护quorun机制来相应其他实例的heartbeat和election请求。Arbiter不保存数据，所以是非常轻量，可以不用独立的服务器。

![Alt text](./pic/mongo2.svg)

- One primary.
- One secondary member. The secondary can become primary in an election.
- One arbiter. The arbiter only votes in elections.

![Alt text](./pic/mongo4.svg)

#### Server选择算法

MongoDB drivers使用Server选择算法来决定哪个副本集中的成员来读写，Mongo可以控制读写分离，虽然默认是从Primary读写。
Server的选择在每次读写操作时发生，在配置里由read preference 和 localThresholdMS 决定。Multi-document 事物包含读操作必须使用read preference 为 primary.

### 水平扩展(分片Sharding)

Mongodb使用Sharding来支持大数据和大流量操作。因为单机的CPU, RAM, I/O都有限制。

- shard: Each shard contains a subset of the sharded data. Each shard can be deployed as a replica set.
- mongos: The mongos acts as a query router, providing an interface between client applications and the sharded cluster.
- config servers: Config servers store metadata and configuration settings for the cluster. As of MongoDB 3.4, config servers must be deployed as a replica set (CSRS).

![Alt text](./pic/mongo5.svg)

MongoDB shards data at the collection level, distributing the collection data across the shards in the cluster.

块(chunk): MongoDB将数据拆分为chunk，每个chunk都是collection中的一段连续的数据记录，为防止一个chunk变的越来越大，当一个chunk增加到特定大小时，会被自动拆分为两个较小的chunk。

#### Balancer and Even Chunk Distribution

In an attempt to achieve an even distribution of chunks across all shards in the cluster, a balancer runs in the background to migrate chunks across the shards .

![Alt text](./pic/mongo6.svg)

#### Reads / Writes

For queries that include the shard key or the prefix of a compound shard key, mongos can target the query at a specific shard or set of shards. These targeted operations are generally more efficient than broadcasting to every shard in the cluster.

If queries do not include the shard key or the prefix of a compound shard key, mongos performs a broadcast operation, querying all shards in the sharded cluster. These scatter/gather queries can be long running operations

#### Sharding Strategy

Hashed Sharding: Hashed Sharding involves computing a hash of the shard key field’s value. Each chunk is then assigned a range based on the hashed shard key values

![Alt text](./pic/mongo7.svg)

Ranged Sharding: Ranged sharding involves dividing data into ranges based on the shard key values. Each chunk is then assigned a range based on the shard key values

![Alt text](./pic/mongo8.svg)
