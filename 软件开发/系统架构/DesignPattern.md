---
title: Docker
date: 2019-05-24 22:06:47
categories: 
- 软件开发
- 系统架构
---

### 设计模式学习笔记
- from : http://www.cnblogs.com/maowang1991/archive/2013/04/15/3023236.html
 
#### 设计模式的分类

```
五种创建者模式 ： 单例模式，工厂方法模式，抽象工厂模式，建造者模式，原型模式
七种结构型模式 ： 适配器模式，装饰器模式，代理模式，外观模式，桥接模式，组合模式，享元模式
十一种行为模式 ： 策略模式，模板方法模式，观察者模式，迭代子模式，责任链模式，命令模式，备忘录模式，状态模式，访问者模式，中介者模式，解释器模式
并发型模式 ： Future模式,Master_worker模式,Guarded Suspension模式,不变模式,生产者消费者模式　
线程池模式 : HS/HA半同步/半异步模式，L/F领导者跟随者模式
```

#### 设计模式六大原则

```
开闭原则 ： 对扩展开放，修改关闭
里氏代换原则 ： 任何基类出现的地方，子类一定可以出现
依赖倒置原则 ： 依赖抽象，不依赖具体
接口隔离原则 ： 使用多个隔离的接口，而不是单个接口包括所有方法
迪米特法则 ： 实体尽量少和其他实体发生相互作用  
合成复用原则 ： 尽量使用合成聚合而不是继承
```

#### 23种设计模式
##### 五种创建者模式

```
1. 单例模式 ： JVM中只创建一个实例存在，反复使用,严格单例需要控制线程安全，反序列化创建对象
2. 工厂方法模式
    普通工厂模式 ： 建立一个工厂类，对实现同一接口的类进行实例创建，多个实例共用一个工厂方法
    多个工厂方法模式 ： 对普通工厂改进，每一类实例的创建对应一个工厂方法
    静态工厂方法模式 ： 对多个工厂方法模式改进，将方法设置为静态的，不再需要创建工厂实例
3. 抽象工厂模式 ： 抽象工厂模式，创建多个工厂类，这样一旦需要增加新的功能，只需增加新的工厂类，不需要修改原有代码
4. 建造者模式 ： 建造者是创建复合对象，工厂模式创建单个产品
5. 原型模式 ： 对一个已有对象的复制产生一个和原对象类似的新对象，通过clone
    浅复制 ： 基本数据类型的变量会被重新创建，引用类型还是指向原对象 (Object.clone就是浅拷贝)
    深复制 ： 基本数据类型和引用类型被重新创建 (写入读出二进制流产生新对象)
```

##### 七种结构型模式
       
```
1. 适配器模式
    类的适配器模式 ： 接口Targetable拥有和A相同的方法，并有新的适配方法，类Adapter继承A实现Targetable
    对象的适配器模式 ： 和类适配器不同的是，持有A的实例而不是继承A
    接口的适配器模式 ： 解决有时候并不想实现接口中的所有的方法，让抽象类B实现接口C，其他的实现类只需要继承B
2. 装饰器模式 ： 给一个对象动态增加新的功能，装饰对象B实现被装饰对象A相同的接口，并且B持有A的实例，用户更关注被装饰后的功能
3. 代理模式 ： 类Proxy实现被代理的类A相同的接口，并持有A的实例，实现类似装饰器模式，但用户更关注被代理的对象功能 (可参考JDK proxy)
4. 外观模式 ： 解决类与类之间的依赖关系，将其他的类组合在一起
5. 桥接模式 ： 把事物和具体实现分开，使得二者可以独立变化 (参考JDBC的不同数据库驱动加载)
6. 组合模式 ： 多个对象组合在一起进行操作,整体和个体的设计(参考二叉树，目录)
7. 享元模式 ： 实现对象的共享(参考数据库连接池的实现，commons-pool开源实现)
```
        
##### 十一种行为模式
        

```
1. 父类和子类
    策略模式 : 多个子类实现同一个接口，用户按自己的选择选用不同的实现，如排序接口，具体实现快排，堆排等
    模板方法模式 ： 抽象类定义主方法，子类继承抽象类，选择实现父类的方法，通过调用父类实现对子类的调用
2. 两个类之间
    观察者模式 : 观察者先订阅，被观察者变化时通知列表内的观察者
    迭代子模式 : 用于遍历聚集中的对象，如集合,Iterator持有遍历对象实例，对其进行顺序访问
    责任链模式 : 一个实例对象调用自己的实例去处理一个任务，然后递归，始终会有一个对象去处理这个任务，这个查找链不限于链表和树等
    命令模式 ： 实现和请求分开，如controller和service层的分离
3. 类的状态
    备忘录模式 : 原始类A创建备忘类B保存在C中，B保存A的属性，C只能新增不能修改
    状态模式 ： 类A有不同状态Status，不同的状态同一方法对应不同的行为
4. 通过中间类
    访问者模式 ： 分离对象数据结构和行为的方法，解决为现有类A新增功能，不能修改A的代码的情况,缺点是不适用数据结构易于变化的场景
    中介者模式 ： 为降低类的耦合性，只需保持其它类和中间类的关系，不需要类之间相互持有实例对象
    解释器模式 ： 类似编译器，正则表达式实现，使用场景受限
```

##### 并发型模式 

```
1. 主动对象模式 Active Object : 自带处理线程，其他请求进入缓冲区等待异步执行，调用和执行分离
2. 阻碍模式 Balking Pattern : 设置一个共享变量，当线程进入一个方法，判断该值是否为真，如果为真说明已经在执行了，返回结束，否则设为真并执行
3. 双重检查锁定 Double Checked Locking ：　参考单例模式实例的初始化双检查
4. 守卫模式 Guarded　：　判断共享变量是否为真，当为假wait,等待条件为真时notify
5. 领导者/追随者模式 Leaders/Followers : 每个线程共享一个事件源，并在三个状态切换leader、follower和processor;leader接受事件，状态变成processor，选举一个新的leader，事件处理完状态变成follower；不需要线程的上下文切换
6. 监测对象模式 Monitor object : 互斥执行和协作。使用ｓｙｎｃｈｒｏｎｉｚｅｄ和wait/notify/notifyAll
7. 读写锁 Read-write lock　：　读写锁分离，增加吞吐量    
8. 调度模式 Scheduler ： 定期处理(Timer)
9. 线程池模式    Thread pool ： 线程被当作资源管理分配
10. 线程特定存储 Thread-specific storage : 将变量保存在ＴｈｒｅａｄLocal中，避免重复创建或从其他地方获取
```

##### Java 3种并发实现
        

```
1. Thread : 直接使用Thread/Runnable/Future
2. Executors和Services ： 线程池技术来控制应用程序的并发，线程数通常和业务相关于cpu不相关，需要上下文切换实现并发，任务从开始到结束时间是不稳定的，执行过程中需要抢占cpu
3. ForkJoin框架和并行流 ： cpu数来控制并行，并发数量不会大于cpu的并发数
```

##### Java并发策略

```
1. Future模式:　提高响应速度
2. Master_worker模式: 子任务分配，提高响应速度　
3. Guarded Suspension模式 : 队列缓冲，非立即处理，避免因为请求太多而崩溃
4. 不变模式: 类似String/Double...不需要同步，线程安全
5. 生产者消费者模式　:　缓解两者间的性能差
```
