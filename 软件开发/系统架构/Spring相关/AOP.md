---
title: AOP
date: 2019-05-24 22:06:47
categories: 
- 软件开发
- 系统架构
- Spring
---

## AOP相关设计与实现解析
功能增强相关的技术：回调，Proxy，Filter，Listener，Interceptor，AOP
1. 回调
回调是最简单也是在各框架应用最广泛的技术手法，可达到控制反转的效果，是模板方法模式的一种实现，一般来说是先写一个抽象类，把其中的回调方法写成抽象方法也就是说子类必须实现的方法，以此实现对子类中方法的回调，也是IOC的基础。这种方法与默认适配法模式刚好相反，前者声明抽象方法是为了强制子类重写，后者是为一个接口先实现一个子类写入很多空方法为的是其子类不必实现所有接口方法。
2. Proxy
代理模式也是用来功能增强的，它实现与代理对象相同的接口，并且包含代理对象，来实现透明的功能增强，因为调用代理类与调用代理对象相同所以说做代理。Java中最常用的就是动态代理了，只能给它相应的接口和代理对象就能在运行时动态的生成代理类，当然用于功能增强的Handler要自己写了。
3. Filter
Servlet中相当标准的filter其实它就是一个回调模式的实现,在某操作之前可能调用某个方法，最后再用一个责任链到传到下一个filter
4. Listener(观察者模式)
该模式在C/S开发中是基础，因为要监听组件的事件及状态等。被观察者包含一组观察者（也可说观察者注册在被观察者中），可以在某一事件发生前后调用相应的观察者，来达到监听对象的效果。
5. Interceptor
感觉这种实现方法与Listener基本相同，如果有一点不同的话就是Interceptor实现时要和被拦截对象递归来做，因为要用一个Interceptor对象来实现方法前后的拦截。
6. AOP
AOP就是以上这些方法的更进一步的应用，应该是把以上这些功能增强的应用抽象出来了，因为以上这些方法都有侵入性太强的感觉，而AOP抽象出来形成一个应用层次。
AOP的实现方式也有很多，一般由实现的由易到难的度分为：
- 动态代理：由java中的动态代理实现，但只能对接口增强
- 代码生成：不太常用了
- 字节码生成：CGLIB可以实现，可对非接口类增强
- 类加载器增强：Jboss就是用实现自有类加载器来实现，可以new时动态增强
- 语言增强：AspectJ用java的扩展语言来实现

　　更确切地说，我们在比较AOP的拦截器和Decorator模式，它们非常相似，一些AOP框架本身就是使用Decorator模式来实现拦截器功能的。 

　　过滤器是架构设计模式中比较常用的一种，几乎每个灵活动态系统都需要过滤器，特别是当我们的数据以内存状态出现时，过滤器无疑成为领域层的一 个核心业务逻辑，当然如果你还是使用面向数据库的编程模式，过滤器功能就被你用SQL语句的where语法给替代了，

　　当我们在一个AOP框架下编程，经常会问自己，到底过滤器这个功能是应该做成拦截器还是 Decorator，当我在Jdon Framework下重写JiveJdon时就不只一次的问我自己。

　　其实这是一个分析模式中的过滤器实现问题，也是一个现实设计的问题：在Servlet Filter和职责链以及装饰模式Decorator和AOP几个方面如何选择？ 

　　选择标准无外乎软件的两个终极目标：简单和高质量；高质量是反映在细粒度方面，简单则是在进行设计实现时比较容易方便。 

　　在粒度粗细方面，又有一个衡量指标：功能覆盖范围，也是一个scope，例如：如果功能需求要为某个类的方法实现实现过滤，但是，你使用一个Servlet Filter这样过滤器实现，虽然 它也能够实现我们的目标，但是它对所有的Servlet请求都进行过滤，这无疑范了杀鸡取卵的错误，造成系统性能上的损失。 

　　以一个具体案例为例子： 
　　我们在论坛显示时，希望动态过滤掉不应该出现的字眼，也就是在帖子显示之前，加载一个过滤器，对内容进行替换。 

　　这里的Model是ForumMessage,而对应的Service则是ForumMessageService； ForumMessageService的getMessage可以获得帖子内容，这里我们在getMessage之前加一个过滤器；那么这里应该如何选 择呢？ 

　　因为我在Jdon Framework这样的Ioc/AOP框架下实现，所以想到的是AOP，我们定义一个拦截器，拦截的对象是ForumMessageService的getMessage方法，进行配置文件配置即可。

　　AOP的拦截器实现原理也是这样，当然，正是有这种考虑，所以所有AOP框 架内，只有 AspectJ性能是最好的，因为它在你编译代码时就将你的拦截意图实现了，这属于静态织入 weaving，这就类似你自己写代码实现，但是与你自己写代码不同的是，你自己不但要写拦截器，而且还要自己手工将拦截器语句插入被拦截的那段代码，现 在，使用AspectJ你就不用做后者了，这也是整合了AspectJ的Spring 2.0给我们带来的效能。所以，为了在编译代码时做手脚，就不能使用SUN的JDK原来的javac了，必须用他们自己特定的javac了。有得必有失 吧。 

　　理解了AOP拦截器拦截的原理，你可能感慨：原来所有的动态AOP（不改换编译器的AOP框架）拦截效能没有Decorator直接指定要快啊。所以，如果你在编码设计阶段，可以知道你所要拦截的方法，那么，无疑直接使用Decorator模式组成过滤器是一种好方式。 

　　这也是我先期不怎么看好使用动态AOP实现的Spring 1.X版本，也不太热衷于同样使用 
动态AOP实现、虽符合EJB 3.0规范的JBoss 4.0了。可是，为什么总是有人迫不及待地告别EJB 2.x，夸张Spring，然后又狂炫EJB 3.0。在接纳他们之前，先把盒子打开看看验货一下，做一个普通的消费者应有的理性。 

　　当然，不是说动态AOP没有用武之地，它类似SOA的集成作用，可以在不用修改原来代码结构上强行加入过滤器。而且AOP不只是拦截器，还有introduction，这一神奇功能可以突破Java单继承法则，显得象儿童世界里面的神奇魔法一样。 

　　从某个方面来说，动态AOP和 职责链非常类似，职责链类似击鼓传花，更像典型的打太极拳，推来推去，这也是政府效率不高的主要原因，同样，用在软件系统里，性能最差。想象一下，当这朵 花传到真正主人面前时，而这个主人是传花环节中最后一个，这种效率和直接抛绣球一样，直接将花抛给真正主人相比，无疑最耗时间的，所以击鼓传花游戏就是玩 的这个耗时间，在鼓声中，消耗时间，煎熬折磨你的心思，它玩的不是要把花如何快速准确地送给某人，它的目的性不确切。 

　　我们的软件系统不能这么玩吧？ 

　　总结如下：过滤器实现方式在不保证功能前提下，从性能角度考虑有如下先后顺序：Decorator或Proxy模式；AOP拦截器。 

　　考虑使用AOP拦截器时，最好选择那些受众面积比较广的功能，例如一些基础通用功能：权限检查；事务机制；Pool等，这些功能不是针对某个具体类或方法（方法权限除外），而是一系列类，这样使用动态AOP拦截器，就是有些性能损耗也是值得的，而且是必要的，使用其他方法也会引起这样的损耗。 

　　如果过滤器是业务逻辑的一部分，而且在设计时，我们可以确定这些过滤器，这样我们使用Decorator模式或Proxy模式进行特定指定的拦截，当然，因为每个类/接口都需要一个附加的Decorator/Proxy，如果某个过滤功能是很多类都需要的，