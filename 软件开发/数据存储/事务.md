数据库事务具有ACID特性
1、	数据库系统釆用日志来保证事务的原子性、一致性和持久性，发生错误时根据日志来回滚回事取消更新。
2、	釆用锁机制来实现事务的隔离性。有共享锁，更新锁，独占锁等。
数据库事务是为了保证数据的正确无误。
多事务并发时会引起，脏读，虚读，不可重复读，丢失更新等问题。这些问题都可以通过加锁机制来解决。加锁的方法：1、在事务中对资源显示（手工）的加锁。2、数据库系统自动管理锁。通常情况下优先使用数据库自动管理锁，它会分析事务中的SQL语句，然后自动为SQL语句所操作的数据资源加上合适的锁，而且在锁的数目太多时，会自动进行锁升级，以提高系统性能。

为了能让用户在事务的隔离性与并发性之间做出合理的权衡，数据库系统提供了四种事务隔离级别。
1、	Serializable：串行化
2、	Repeatable Read：可重复读
3、	Read Commited：读已提交数据
4、	Read Uncommited：读未提交的数据

通常情况下可以把隔离级别设为Read Commited，它能避免脏读，而且有较好的并发性能。尽管它会导致不可重复读、虚读和第二类更新丢失等问题，在可能出现这类问题的个别场合可以由应用程序釆用悲观锁或乐观锁来控制。
JTA
1.	当需要使用多个事务性资源时，才需要使用JTA（典型应用，关系数据库与消息队列）。而大多数应用并不需要跨多个数据源(也就是说多个connection)，许多高端应用使用单一的，高伸缩性的数据库如Oracle 9i
2.	J2EE有两个事务管理的选择：　全局或本地事务。全局事务由应用服务器管理，使用JTA。局部事务是和资源相关的，比如一个和JDBC连接关联的事务。

Spring 的 TransactionDefinition接口指定：
1．	事务隔离：当前事务和其它事务的隔离的程度。例如，这个事务能否看到其他事务未提交的数据。
2．	事务传播：嵌套事务中使用，通常在一个事务中执行的所有代码都会在这个事务中运行。但是，如果一上事务上下文已经存在，有几个选项可以指定一个事务性方法的执行行为：例如，简单地在现有的事务中继续运行（大多数情况）；或者挂起现有事务，创建一个新的事务。Spring提供EJB　CMT中常见的事务传播选项。
3．	事务超时：事务在超时前能动行多久（自动被底层的事务基础设施回滚）。
4．	只读状态：只读事务不修改任何数据。只读事务在某些情况下（例如当使用Hibernate时），是一个非常有用的优化。
Spring 默认在程序throw UnCheckException时回滚事务，throw CheckException时不做事务的回滚，这点需要注意。

如果看的仔细可以看出以下几点，事务操作基本上是一个整体的，理清以后可以看出巨完整。以下就来连起来说一下：
1．	当数据库被一群牛人从外星带来以后，为了做到一次完整业务操作不会因为中途的操作失败而使用数据库中的数据错误的问题，牛人们决定启用数据库事务来保证数据的正确性。
2．	他们用数据库日志来保证一次完整的操作，用加锁机制来保证并发访问的情况下的一系列问题。
3．	数据库日志没什么好说的，那些老大不让咱们动，一般也不用在程序中动。就来说一下加锁机制好了，咱们可以手动加锁，也可以用数据库系统提供的事务隔离级别来做自动加锁，如果你也是也狂牛，你可以用全手动加锁：）嘿嘿嘿！一般来说都是用事务隔离级别＋部分手动加锁在程序里实现事务性功能。
4．	以上几点就是整个事务的一个层次结构，当然还有一些细节的东西，那些可以在个体应用时再看了。


在所有使用 spring 的应用中, 声明式事务管理可能是使用率最高的功能了, 但是, 从我观察到的情况看, 
绝大多数人并不能深刻理解事务声明中不同事务传播属性配置的的含义, 让我们来看一下 TransactionDefinition 接口中的定义
 在 spring 中一共定义了六种事务传播属性, 如果你觉得看起来不够直观, 那么我来转贴一个满大街都有的翻译
引用
PROPAGATION_REQUIRED -- 支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择。 
PROPAGATION_SUPPORTS -- 支持当前事务，如果当前没有事务，就以非事务方式执行。 
PROPAGATION_MANDATORY -- 支持当前事务，如果当前没有事务，就抛出异常。 
PROPAGATION_REQUIRES_NEW -- 新建事务，如果当前存在事务，把当前事务挂起。 
PROPAGATION_NOT_SUPPORTED -- 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。 
PROPAGATION_NEVER -- 以非事务方式执行，如果当前存在事务，则抛出异常。 
PROPAGATION_NESTED -- 如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则进行与PROPAGATION_REQUIRED类似的操作。 
前六个策略类似于EJB CMT，第七个（PROPAGATION_NESTED）是Spring所提供的一个特殊变量。 
它要求事务管理器或者使用JDBC 3.0 Savepoint API提供嵌套事务行为（如Spring的DataSourceTransactionManager） 
认为 Service 之间应该避免互相调用, 其实根本不用担心这点， 

PROPAGATION_REQUIRES_NEW 启动一个新的, 不依赖于环境的 "内部" 事务. 这个事务将被完全 commited 或 rolled back 而不依赖于外部事务, 它拥有自己的隔离范围, 自己的锁, 等等. 当内部事务开始执行时, 外部事务将被挂起, 内务事务结束时, 外部事务将继续执行. 
另一方面, PROPAGATION_NESTED 开始一个 "嵌套的" 事务, 它是已经存在事务的一个真正的子事务. 潜套事务开始执行时, 它将取得一个 savepoint. 如果这个嵌套事务失败, 我们将回滚到此 savepoint. 潜套事务是外部事务的一部分, 只有外部事务结束后它才会被提交.
1.	由此可见, PROPAGATION_REQUIRES_NEW 和 PROPAGATION_NESTED 的最大区别在于, PROPAGATION_REQUIRES_NEW 完全是一个新的事务, 而 PROPAGATION_NESTED 则是外部事务的子事务, 如果外部事务 commit, 潜套事务也会被 commit, 这个规则同样适用于 roll back. 

2. 代码不做任何修改, 那么如果内部事务(即 ServiceB#methodB) rollback, 那么首先 ServiceB.methodB 回滚到它执行之前的 SavePoint(在任何情况下都会如此), 
外部事务(即 ServiceA#methodA) 将根据具体的配置决定自己是 commit 还是 rollback (+MyCheckedException). 

上面大致讲述了潜套事务的使用场景, 下面我们来看如何在 spring 中使用 PROPAGATION_NESTED, 首先来看 AbstractPlatformTransactionManager
1. 我们要设置 transactionManager 的 nestedTransactionAllowed 属性为 true, 注意, 此属性默认为 false!!!
可以看到 Savepoint 是 SavepointManager.createSavepoint 实现的, 再看 SavepointManager 的层次结构, 发现 
其 Template 实现是 JdbcTransactionObjectSupport, 常用的 DatasourceTransactionManager, HibernateTransactionManager 
中的 TransactonObject 都是它的子类 :

JdbcTransactionObjectSupport 告诉我们必须要满足两个条件才能 createSavepoint : 

2. java.sql.Savepoint 必须存在, 即 jdk 版本要 1.4+ 
3. Connection.getMetaData().supportsSavepoints() 必须为 true, 即 jdbc drive 必须支持 JDBC 3.0 
确保以上条件都满足后, 你就可以尝试使用 PROPAGATION_NESTED 了. 


